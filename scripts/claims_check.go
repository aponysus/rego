package main

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	claimIDPattern   = regexp.MustCompile(`Claim-ID:\s*([A-Za-z0-9_-]+)`)
	generatedMarkers = []string{
		"<!-- Generated by scripts/gen_reference.go; do not edit by hand. -->",
		"<!-- GENERATED: DO NOT EDIT -->",
	}
	ignoreMarker = "<!-- claims-scan: ignore -->"
)

type ledgerEntry struct {
	ID        string
	Claim     string
	Location  string
	Code      string
	Status    string
	RawLine   string
	LineIndex int
}

func main() {
	root, err := os.Getwd()
	if err != nil {
		fail(err)
	}

	ledgerPath := filepath.Join(root, "docs", "claims-ledger.md")
	entries, ledgerErrs := parseLedger(ledgerPath)

	claimIDs, scanErrs := scanClaimIDs(root)

	var errs []error
	errs = append(errs, ledgerErrs...)
	errs = append(errs, scanErrs...)

	for id, files := range claimIDs {
		if _, ok := entries[id]; !ok {
			errs = append(errs, fmt.Errorf("missing Claim-ID in ledger: %s (found in %s)", id, strings.Join(files, ", ")))
		}
	}

	if len(errs) > 0 {
		for _, err := range errs {
			fmt.Fprintln(os.Stderr, err)
		}
		os.Exit(1)
	}
}

func scanClaimIDs(root string) (map[string][]string, []error) {
	targets := make([]string, 0, 64)
	var errs []error

	readme := filepath.Join(root, "README.md")
	if fileExists(readme) {
		targets = append(targets, readme)
	}

	docsDir := filepath.Join(root, "docs")
	if dirExists(docsDir) {
		if err := filepath.WalkDir(docsDir, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if filepath.Ext(path) != ".md" {
				return nil
			}
			targets = append(targets, path)
			return nil
		}); err != nil {
			errs = append(errs, fmt.Errorf("walk docs: %w", err))
		}
	}

	ids := make(map[string][]string)
	for _, path := range targets {
		if filepath.Base(path) == "claims-ledger.md" {
			continue
		}
		body, err := os.ReadFile(path)
		if err != nil {
			errs = append(errs, fmt.Errorf("read %s: %w", path, err))
			continue
		}
		content := string(body)
		if shouldIgnore(content) {
			continue
		}
		matches := claimIDPattern.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) < 2 {
				continue
			}
			id := match[1]
			ids[id] = append(ids[id], filepath.ToSlash(path))
		}
	}

	return ids, errs
}

func parseLedger(path string) (map[string]ledgerEntry, []error) {
	body, err := os.ReadFile(path)
	if err != nil {
		return nil, []error{fmt.Errorf("read claims ledger: %w", err)}
	}

	lines := splitLines(string(body))
	headerIdx := -1
	header := []string{}
	for i, line := range lines {
		if !strings.HasPrefix(strings.TrimSpace(line), "|") {
			continue
		}
		cols := splitRow(line)
		if hasColumn(cols, "claim-id") {
			headerIdx = i
			header = cols
			break
		}
	}
	if headerIdx == -1 {
		return nil, []error{errors.New("claims ledger missing header row with Claim-ID column")}
	}

	colIndex := make(map[string]int)
	for i, col := range header {
		colIndex[strings.ToLower(col)] = i
	}

	required := []string{"claim-id", "claim", "doc location", "code source", "status"}
	var errs []error
	for _, col := range required {
		if _, ok := colIndex[col]; !ok {
			errs = append(errs, fmt.Errorf("claims ledger missing required column: %s", col))
		}
	}
	if len(errs) > 0 {
		return nil, errs
	}

	entries := make(map[string]ledgerEntry)
	for i := headerIdx + 1; i < len(lines); i++ {
		line := lines[i]
		if !strings.HasPrefix(strings.TrimSpace(line), "|") {
			continue
		}
		cols := splitRow(line)
		if isSeparatorRow(cols) {
			continue
		}
		id := getColumn(cols, colIndex, "claim-id")
		if id == "" {
			continue
		}
		if _, ok := entries[id]; ok {
			errs = append(errs, fmt.Errorf("duplicate Claim-ID in ledger: %s", id))
			continue
		}
		entry := ledgerEntry{
			ID:        id,
			Claim:     getColumn(cols, colIndex, "claim"),
			Location:  getColumn(cols, colIndex, "doc location"),
			Code:      getColumn(cols, colIndex, "code source"),
			Status:    strings.ToLower(getColumn(cols, colIndex, "status")),
			RawLine:   line,
			LineIndex: i + 1,
		}
		if entry.Status == "verified" && strings.TrimSpace(entry.Code) == "" {
			errs = append(errs, fmt.Errorf("ledger entry %s missing code source (line %d)", entry.ID, entry.LineIndex))
		}
		entries[id] = entry
	}

	return entries, errs
}

func splitLines(s string) []string {
	s = strings.ReplaceAll(s, "\r\n", "\n")
	return strings.Split(s, "\n")
}

func splitRow(line string) []string {
	line = strings.TrimSpace(line)
	line = strings.TrimPrefix(line, "|")
	line = strings.TrimSuffix(line, "|")
	parts := strings.Split(line, "|")
	for i := range parts {
		parts[i] = strings.TrimSpace(parts[i])
	}
	return parts
}

func hasColumn(cols []string, name string) bool {
	needle := strings.ToLower(name)
	for _, col := range cols {
		if strings.ToLower(col) == needle {
			return true
		}
	}
	return false
}

func getColumn(cols []string, idx map[string]int, name string) string {
	i, ok := idx[name]
	if !ok || i >= len(cols) {
		return ""
	}
	return cols[i]
}

func isSeparatorRow(cols []string) bool {
	if len(cols) == 0 {
		return false
	}
	allDash := true
	for _, col := range cols {
		col = strings.TrimSpace(col)
		if col == "" {
			continue
		}
		for _, r := range col {
			if r != '-' {
				allDash = false
				break
			}
		}
		if !allDash {
			return false
		}
	}
	return allDash
}

func shouldIgnore(content string) bool {
	if strings.Contains(content, ignoreMarker) {
		return true
	}
	for _, marker := range generatedMarkers {
		if strings.Contains(content, marker) {
			return true
		}
	}
	return false
}

func fileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

func dirExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && info.IsDir()
}

func fail(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}
